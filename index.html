<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Housing Inventory Explorer</title>
    <script type="module" src="https://js.arcgis.com/calcite-components/2.1.0/calcite.esm.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/2.1.0/calcite.css"/>
    <!-- Load the Chart.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/dark/main.css" />
    <script src="https://js.arcgis.com/4.28/"></script>
    <script src="js/symbology.js"></script>
    <link rel="stylesheet" href="css/style.css">

    <script>
      // sets the calcite select boxes to a specified value
      function setCalciteSelectValue(selectElement, newValue) {
  
        // Find the option with the specified value
        const optionToSelect = Array.from(selectElement.children)
          .find(option => option.value === newValue);

        if (optionToSelect) {
          // Set the 'selected' attribute on the option
          optionToSelect.setAttribute('selected', '');

          // Dispatch a 'change' event to simulate user interaction
          const changeEvent = new Event('change', { bubbles: true });
          selectElement.dispatchEvent(changeEvent);
        }
      }

      // read in a local json
      function fetchLocalJsonArray(filePath) {
        return fetch(filePath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .catch(error => {
            console.error('Error reading JSON file:', error);
          });
      }

      // populate a select box
      function populateSelectBox(selectName, array) {
        const selectBox = document.getElementById(selectName);

        // Clear existing options
        selectBox.innerHTML = '';

        // Populate with options from the array
        array.forEach(item => {
          const option = document.createElement('calcite-option');
          // option.value = item.value;  // Set the value attribute if needed
          option.setAttribute('value', item)
          option.setAttribute('label', item)
          // option.text = item;    // Set the text content of the option
          selectBox.appendChild(option);
      });
    }
      
      // populate a combobox
      function populateComboBox (comboBoxName, array) {
          const comboBox = document.getElementById(comboBoxName);

          // Populate with options from the array
          array.forEach(item => {
            const comboItem  = document.createElement('calcite-combobox-item');
            // option.value = item.value;  // Set the value attribute if needed
            comboItem.setAttribute('value', item)
            comboItem.setAttribute('text-label', item)
            comboBox.appendChild(comboItem);
        });
      }


      require(["esri/config",
               "esri/Map", 
               "esri/geometry/Point",
               "esri/layers/FeatureLayer", 
               "esri/views/MapView", 
               "esri/widgets/Legend",
               "esri/widgets/TimeSlider",
               "esri/widgets/Expand",
               "esri/widgets/BasemapGallery",
               "esri/core/reactiveUtils",
               "esri/rest/support/Query"], (
        esriConfig,
        Map,
        Point,
        FeatureLayer,
        MapView,
        Legend,
        TimeSlider,
        Expand,
        BasemapGallery,
        reactiveUtils,
        Query
      ) => {

        esriConfig.apiKey = "AAPK5915b242a27845f389e0a11a17dc46b46gXNFj09FJVdb711lVLGhgoVFJBqdW6ow3bl71N1hx2llpMyogGBeF8kgvrKm3cY";

        // store the base url
        const providedURL =  window.location;
        let newURL = new URL(providedURL)
        const urlParamsToggle = true;

        // store paths to jsons
        const jsonBase = 'json/BASE.json';
        const jsonCounty = 'json/COUNTY.json';
        const jsonCity = 'json/CITY.json';
        const jsonCenter = 'json/CENTER.json';
        const jsonType = 'json/TYPE.json';
        
        let activeLayer;

        // initialize geographic filter options
        fetchLocalJsonArray(jsonBase)
        .then(data => {
          const countyArray = data[0].COUNTY;
          const cityArray = data[0].CITY;
          const centerArray = data[0].CENTER;
          populateSelectBox('countySelect', countyArray);
          populateSelectBox('citySelect', cityArray);
          populateSelectBox('centerSelect', centerArray);
        });

        // initialize housing type options
        fetchLocalJsonArray(jsonType)
        .then(data => {
          const subtypeArray = data[0].SUBTYPE;
          populateComboBox('subtypeSelect', subtypeArray);
        });

        const countiesLayer = new FeatureLayer({
                outFields: ["CO_NAME"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/Boundaries_gdb/FeatureServer/1",
                renderer:countyRenderer,
                // maxScale: 50000,
                visible: false
              });
              
        const citiesLayer = new FeatureLayer({
                outFields: ["NAME"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/Boundaries_gdb/FeatureServer/0",
                renderer:cityRenderer,
                // maxScale: 20000,
                // minScale: 100000,
                visible: false
        
              });

        const centersLayer = new FeatureLayer({
                outFields: ["AreaName"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/Boundaries_gdb/FeatureServer/2",
                renderer:centerRenderer,
                // maxScale: 2000,
                // minScale: 50000,
                visible: false
              });

        const ParcelsLayer = new FeatureLayer({
            outFields: ["*"],
            url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/0",
            renderer:parcelRenderer,
            maxScale: 0,
            visible: false,
            popupTemplate:parcelPopupTemplate
          });
        
        const PointsLayer = new FeatureLayer({
            url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/1",
            renderer:pointRenderer,
            outFields: ["*"],
            visible: true,
          });


        // Create the Map and View objects
        const defaultZoom = 10
        const map = new Map({
          basemap: "satellite",
          layers: [centersLayer, citiesLayer, countiesLayer, PointsLayer, ParcelsLayer],
        });

        const view = new MapView({
          container: "viewDiv",
          map: map,
          zoom: defaultZoom,
          center: [-111.98, 40.94]
        });

        if (providedURL.href.includes('?') === false) {
          activeLayer = PointsLayer;
        }

        // view.ui.move("zoom", "top-right");


        // create the base map gallery expand object
        const basemapGallery = new BasemapGallery({
                view: view,
                container: document.createElement("div")
              });

        // Create an Expand instance and set the content
        // property to the DOM node of the basemap gallery widget
        // Use an Esri icon font to represent the content inside
        // of the Expand widget
        const bgExpand = new Expand({
          expandTooltip: "Basemap",
          view: view,
          content: basemapGallery,
          group: "top-right"
        });

        // add the App Info chart div
        const infoDiv = document.getElementById("infoDiv");
        const infoDivExpand = new Expand({
          expandIcon: "information",
          expandTooltip: "Info",
          view,
          content: infoDiv,
          expanded: false,
          group: "top-right"
        });
        
      

        // close the expand whenever a basemap is selected
        // on mobile devices
        reactiveUtils.watch(
          () => basemapGallery.activeBasemap,
          () => {
            const mobileSize = view.heightBreakpoint === "xsmall" || view.widthBreakpoint === "xsmall";

            if (mobileSize) {
              bgExpand.collapse();
            }
          }
        );

  
        // when the view object is created, create a time slider
        view.when(() => {
                    timeSlider = new TimeSlider({
                      container: "timeSlider",
                      view: view,
                      // full min max of time slider
                      fullTimeExtent: { 
                        start: new Date(1850, 0, 1),
                        end: new Date(2022, 0, 1)
                      },
                      // starting min max of time slider
                      timeExtent:{ 
                        start: new Date(1850, 0, 1),
                        end: new Date(2022, 0, 1)
                      },
                      // play speed, not needed?
                      playRate: 2000, 
                      stops: {
                        interval: {
                          value: 10,
                          unit: "years"
                        }
                      },
                      
                      // set custom labels for the timeslider's min, max, and extent dates
                      labelFormatFunction: (value, type, element, layout) => {
                        const options = {year: 'numeric'}
                        const normal = new Intl.DateTimeFormat("en-us", options);
                        switch (type) {
                          case "min":
                            element.setAttribute("style", "color: #00619B;font-size: 14px;");
                            element.innerText = normal.format(value);
                            break;
                          case "max":
                            element.setAttribute("style", "color: #00619B;font-size: 14px;");
                            element.innerText = normal.format(value);
                            break;
                          case "extent":
                            const year0 = value[0].getFullYear();
                            const year1 = value[1].getFullYear()
                            element.innerText = `Year Built:
                            ${year0} - ${year1}`;
                            break;
                        }
                      }
                    });
                  

                  // Option 1: time slider expand
                  const timeSliderExpand = new Expand({
                      expandIcon: "calendar",
                      expandTooltip: "TimeSlider",
                      view,
                      content: timeSlider.container,
                      expanded: false
                    });
                  
                  view.ui.add(timeSliderExpand, "bottom-left");
                  
                  // watch the time slider for changes
                  reactiveUtils.watch(
                    () => timeSlider.timeExtent,
                    (timeExtent) => {
                      console.log(timeExtent.start.getFullYear());
                      console.log(timeExtent.end.getFullYear())
                    }
                  );

                  // Option 2: add the time slider (non-expandable) to the view, manual allows for div placement
                  // view.ui.add(timeSlider, "manual");
        });

        
        
        // store ui objects as variables
        const countySelect = document.getElementById("countySelect");
        const citySelect = document.getElementById("citySelect");
        const centerSelect = document.getElementById("centerSelect");
        const subtypeSelect = document.getElementById("subtypeSelect");
        const resetButton = document.getElementById("resetButton");
        
        // define default queries
        const defaultCountyQuery = "(COUNTY IS NULL OR COUNTY IS NOT NULL)";
        const defaultCityQuery = "(CITY IS NULL OR CITY IS NOT NULL)";
        const defaultCenterQuery = "(CENTER IS NULL OR CENTER IS NOT NULL)";
        const defaultSubtypeQuery = "(SUBTYPE IS NULL OR SUBTYPE IS NOT NULL)";

        const defaultLRquery = "(DIST_LR IS NULL OR DIST_LR IS NOT NULL)";
        const defaultFRquery = "(DIST_FR IS NULL OR DIST_FR IS NOT NULL)";
        const defaultBRTquery = "(DIST_BRT IS NULL OR DIST_BRT IS NOT NULL)";
        const defaultFWYEquery = "(DIST_FWYE IS NULL OR DIST_FWYE IS NOT NULL)";
        const defaultLogicOperator =  "AND";

        // set initial selection for geography filters - could switch to a placeholder?
        let countySelectionCurrent = "-No Selection-";
        let citySelectionCurrent = "-No Selection-";
        let centerSelectionCurrent = "-No Selection-";

        let countyQuery = defaultCountyQuery;
        let cityQuery = defaultCityQuery;
        let centerQuery = defaultCenterQuery;
        let subtypeQuery = defaultSubtypeQuery;

        let LRquery = null;
        let FRquery = null;
        let BRTquery = null;
        let FWYEquery = null;
        let logicOperator =  defaultLogicOperator;

        let fullQuery = null;

        let countyActive = false;
        let cityActive = false;
        let centerActive = false;

        function generateFullQuery() {
       
          const queryComponents = [countyQuery, cityQuery, centerQuery, subtypeQuery];
          const distArray = [LRquery, FRquery, BRTquery, FWYEquery].filter(item => item !== null);

          const hasDistValues = distArray.length > 0;

          const distQuery = hasDistValues
              ? ` AND (${distArray.join(` ${logicOperator} `)})`
              : '';

          fullQuery = queryComponents.join(' AND ') + distQuery;
          // console.log(fullQuery);
        };

         // define initial definition expression
        const initialDefinitionExpression = generateFullQuery()

        // setup actions for the reset button
        resetButton.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {
          
            // clear the definition expression
            layer.definitionExpression = null;
          });

          countyActive = false
          cityActive = false
          centerActive = false

          fetchLocalJsonArray(jsonBase)
            .then(data => {
              
              const countyArray = data[0].COUNTY;
              const cityArray = data[0].CITY;
              const centerArray = data[0].CENTER;
              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);

            });

            countyQuery = defaultCountyQuery;
            cityQuery = defaultCityQuery;
            centerQuery = defaultCenterQuery;
            subtypeQuery = defaultSubtypeQuery;
            subtypeQuery = defaultSubtypeQuery;
            LRquery = null;
            FRquery = null;
            BRTquery = null;
            FWYEquery = null;
            logicOperator =  defaultLogicOperator;
            
            subtypeSelect.value = null;
            inputLR.value = null;
            inputFR.value = null;
            inputBRT.value = null;
            inputFWYE.value = null;
            logicOperator = "And"; 
            generateFullQuery()
            andButton.style.backgroundColor = "#00619B";
            orButton.style.backgroundColor = "#797979";

          newURL.searchParams.delete('cny');
          newURL.searchParams.delete('cty');
          newURL.searchParams.delete('ctr');
          newURL.searchParams.delete('type');
          newURL.searchParams.delete('lr');
          newURL.searchParams.delete('fr');
          newURL.searchParams.delete('brt');
          newURL.searchParams.delete('fwye');
          andButton.click()
          window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
        });

        // setup actions for the AND button
        andButton.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {  
            logicOperator = "And"; 
            generateFullQuery()
            newURL.searchParams.set("op", logicOperator)
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            layer.definitionExpression = fullQuery;
            andButton.style.backgroundColor = "#00619B";
            orButton.style.backgroundColor = "#797979";
          });
        });

        // setup actions for the OR button
        orButton.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {  
            logicOperator = "Or";
            newURL.searchParams.set("op", logicOperator)
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            generateFullQuery()
            layer.definitionExpression = fullQuery;
            orButton.style.backgroundColor = "#00619B";
            andButton.style.backgroundColor = "#797979";
          });
        });

        // COUNTY - filter and zoom features, update select options
        countySelect.addEventListener("calciteSelectChange", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = event.target.value;

            countySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              newURL.searchParams.delete('cny');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              countyQuery = defaultCountyQuery
              countyActive = false
            }else{
              // update URL params
              newURL.searchParams.set("cny", selectionText)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              countyQuery = `COUNTY = '${selectionText}'`
              countyActive = true
            };

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCounty)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;
              
              if ((cityActive !== true) && (centerActive !== true)){
                populateSelectBox('citySelect', cityArray);
                populateSelectBox('centerSelect', centerArray);   
              }           
              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)

            });
          });
          // housingLayer.queryExtent().then((results) => {
          //   view.goTo(results.extent);
          // });

          // zoom to the boundary layer (faster but zooms farther out)
          const query = new Query();
          query.where = `CO_NAME = '${selectionText}'`;
          countiesLayer.queryExtent(query).then(function(results){
            view.goTo(results.extent);
          });
        });

        // CITY - filter and zoom features, update select options
        citySelect.addEventListener("calciteSelectChange", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            // selectionText = citySelect.options[citySelect.selectedIndex].text;
            selectionText = event.target.value;
            citySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              newURL.searchParams.delete('cty');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              cityQuery = defaultCityQuery;
              cityActive = false;
            }else{
              newURL.searchParams.set("cty", selectionText)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              cityQuery = `CITY = '${selectionText}'`;
              cityActive = true;
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCity)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

             
              if ((countyActive !== true) && (centerActive !== true)){
                populateSelectBox('countySelect', countyArray);
                populateSelectBox('centerSelect', centerArray);              
              } if ((countyActive === true)){
                  populateSelectBox('countySelect', countyArray);
                  populateSelectBox('centerSelect', centerArray);
              } if ((centerActive === true)){
                  populateSelectBox('centerSelect', centerArray);
              }

              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)
            });
          });
          
            // zoom to the boundary layer instead
            const query = new Query();
            query.where = `NAME = '${selectionText}'`;
            citiesLayer.queryExtent(query).then(function(results){
              view.goTo(results.extent);
            });

        });

        // CENTER - filter and zoom features, update select options
        centerSelect.addEventListener("calciteSelectChange", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = event.target.value;
            centerSelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              newURL.searchParams.delete('ctr');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              centerQuery = defaultCenterQuery;
              centerActive = false;
            }else{
              // update URL params
              newURL.searchParams.set("ctr", selectionText)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              centerQuery = `CENTER = '${selectionText}'`
              centerActive = true;
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCenter)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

            
              if ((countyActive !== true) && (cityActive !== true)){
                populateSelectBox('countySelect', countyArray);
                populateSelectBox('citySelect', cityArray);          
              } if ((countyActive === true)){
                  populateSelectBox('countySelect', countyArray);
                  populateSelectBox('citySelect', cityArray);
              } if ((cityActive === true)){
                  populateSelectBox('citySelect', cityArray);
              }

              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)

            });
          });
          
          // zoom to the boundary layer instead
          const query = new Query();
          query.where = `AreaName = '${selectionText}'`;
          centersLayer.queryExtent(query).then(function(results){
            view.goTo(results.extent);
          });

        });

        // SUBTYPE Select
        subtypeSelect.addEventListener("calciteComboboxChange", (event) => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selection = event.target.value;
            console.log(selection);

            if (Array.isArray(selection) == false){
              if(selection === null | selection === " " | selection === ""){
                subtypeQuery = defaultSubtypeQuery
              }else{
                // update URL params
                
                newURL.searchParams.set("type", selection)
                window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

                subtypeQuery = `SUBTYPE IN ('${selection}')`
              }
            }else{
              // const joinedString = selection.join('-');
              newURL.searchParams.set("type", selection)
                window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              selection = selection.map(value => `'${value}'`);
              subtypeQuery = `SUBTYPE IN (${selection})`
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
          });
          queryStatisticsForYearChart();
          queryStatisticsForTypeChart();
        });

        //initialize light rail dist filter
        const inputLR  = document.getElementById("inputLR");
        inputLR.value = null;
        inputLR.addEventListener("calciteInputChange", function(){

            userInput = inputLR.value;
            console.log(typeof(userInput))

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('lr');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              LRquery = defaultLRquery;
              
            }  else {
              // update URL params
              newURL.searchParams.set("lr", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              LRquery = `DIST_LR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });


        //initialize frontrunner dist filter
        const inputFR  = document.getElementById("inputFR");
        inputFR.value = null;
        inputFR.addEventListener("calciteInputChange", function(){

            userInput = inputFR.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              
              newURL.searchParams.delete('fr');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              FRquery = defaultFRquery;
            }  else {
              // update URL params
              newURL.searchParams.set("fr", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              FRquery = `DIST_FR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //initialize BRT dist filter
        const inputBRT  = document.getElementById("inputBRT");
        inputBRT.value = null;
        inputBRT.addEventListener("calciteInputChange", function(){

            userInput = inputBRT.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('brt');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              BRTquery = defaultBRTquery;
            }  else {
              // update URL params
              newURL.searchParams.set("brt", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              BRTquery = `DIST_BRT <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //initialize FWYE dist filter
        const inputFWYE  = document.getElementById("inputFWYE");
        inputFWYE.value = null;
        inputFWYE.addEventListener("calciteInputChange", function(){

            userInput = inputFWYE.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('fwye');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              FWYEquery = defaultFWYEquery;
            } else {
              // update URL params
              newURL.searchParams.set("fwye", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              FWYEquery = `DIST_FWYE <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //==============================================
        // on zoom, change unit of representaion
        //==============================================

        view.watch("zoom", function (newZoom) {
          console.log("Zoom level changed to: ", newZoom);

          if (newZoom >= 15){ 
            ParcelsLayer.visible = true;
            PointsLayer.visible = false;
            activeLayer = ParcelsLayer;
          }
          else if (newZoom < 15 && newZoom > 5){ 
            ParcelsLayer.visible = false;
            PointsLayer.visible = true;
            activeLayer = PointsLayer;
          }
        });


        const sidebarDiv = document.getElementById("sidebarDiv");
        const sidebarExpand = new Expand({
          expandIcon: "sliders-horizontal",
          expandTooltip: "Filters",
          view: view,
          content: sidebarDiv,
          expanded: true,
          // group: "top-left"
        });
        view.ui.add(sidebarExpand, { position: "top-left"});

      //=========================
      // chart stuff
      //=========================

      let yearChart = null;
      let typeChart = null;

      const yearCanvas = document.getElementById("year-chart");
      const typeCanvas = document.getElementById("type-chart");

      function queryStatisticsForYearChart() {

          yearChart.options.title.text = "Built Decade (Loading...)"
          yearChart.update();
    
          // create query definitions for stacked bar chart data
          const decades = ["1840", "1850", "1860", "1870", "1880", "1890", "1900", "1910", "1920", "1930", "1940", "1950", "1960", "1970", "1980", "1990", "2000", "2010", "2020"];
          const subtypes = ["single_family", "duplex", "single_family_adu", "condo", "townhome", "mobile_home_park", "mixed_th/single_family", "apartment"];
          const yearChartDefinitions = [];
          for (const decade of decades) {
            for (const subtype of subtypes) {
              const definition = {
                onStatisticField: `CASE WHEN (BLT_DECADE = '${decade}' AND SUBTYPE = '${subtype}') THEN UNIT_COUNT ELSE 0 END`,
                outStatisticFieldName: `year_${decade}_${subtype}`,
                statisticType: "sum"
              };

              yearChartDefinitions.push(definition);
            }
          }

          // query for stacked bar chart data
          const yearChartQuery = activeLayer.createQuery();
          yearChartQuery.geometry = view.extent;
          yearChartQuery.outStatistics = yearChartDefinitions;

          return activeLayer.queryFeatures(yearChartQuery).then((result) => {
            const yearChartQueryResult = result.features[0].attributes;
            // console.log(yearChartQueryResult)

            
            const decadeTypeCountArray = [];
            for (const property in yearChartQueryResult) {
              if (yearChartQueryResult.hasOwnProperty(property)) {
                const [year, ...typeParts] = property.split('_').slice(1);

                decadeTypeCountArray.push({
                  decade: +year,
                  type: typeParts.join('_'),
                  count: yearChartQueryResult[property]
                });
              }
            }
            // console.log(decadeTypeCountArray);


              // Calculate the sum of counts for each decade
              const decadeSums = decadeTypeCountArray.reduce((acc, entry) => {
                acc[entry.decade] = (acc[entry.decade] || 0) + entry.count;
                return acc;
              }, {});

              // Filter out objects with a sum of 0 and get an array of unique decades
              const filteredArray = decadeTypeCountArray.filter(entry => decadeSums[entry.decade] !== 0);
              const uniqueDecades = [...new Set(filteredArray.map(entry => entry.decade))];
              // console.log(uniqueDecades);
              
              // create data objects for each housing type
              const stackedChartDataObjects = [];
              const typeData = {};
              for (const entry of filteredArray) {
                const { type, count, decade } = entry;

                if (!typeData[type]) {
                  typeData[type] = {
                    label: type,
                    data: [],
                    backgroundColor:null
                  };
                }
                typeData[type].data.push(count);

                // If the decade is not already added to the data object, add it
                if (typeData[type].data.length === 1) {
                  typeData[type].decade = decade;
                }
              }
              // Convert the object values to an array
              for (const type in typeData) {
                if (typeData.hasOwnProperty(type)) {
                  stackedChartDataObjects.push(typeData[type]);
                }
              }
              // console.log(stackedChartDataObjects);

              // Update the backgroundColor attribute using the typeColorMap
              const typeColorMap = {
                "single_family": '#FAECA7',
                "duplex": '#FC921F',
                "single_family_adu": '#E60049',
                "condo": '#BD7EBE',
                "townhome": '#28C830',
                "mobile_home_park": '#9E559C',
                "mixed_th/single_family": '#1E8553',
                "apartment": '#149ECE'
              };
              
              const updatedDataArray = stackedChartDataObjects.map(item => ({
                ...item,
                backgroundColor: typeColorMap[item.label]
              }));

              // console.log(updatedDataArray);
              yearChart.options.title.text = "Built Decade"
              yearChart.update();

              updateStackedChart(yearChart, uniqueDecades,updatedDataArray)
          
          }, console.error);

        }

        function queryStatisticsForTypeChart() {
          
          typeChart.options.title.text = "Housing Type (Loading...)"
          typeChart.update();

          const statDefinitions = [
            {
              onStatisticField: "CASE WHEN SUBTYPE IS NOT NULL THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "total",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'single_family' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "single_family",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'duplex' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "duplex",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'single_family_adu' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "single_family_adu",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'townhome' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "townhome",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'condo' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "condo",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'mobile_home_park' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "mobile_home_park",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'mixed th/single_family' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "mixed_th_single_family",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'apartment' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "apartment",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1840') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1840",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1850') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1850",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1860') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1860",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1870') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1870",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1880') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1880",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1890') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1890",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1900') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1900",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1910') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1910",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1920') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1920",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1930') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1930",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1940') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1940",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1950') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1950",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1960') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1960",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1970') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1970",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1980') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1980",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1990') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1990",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2000') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2000",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2010') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2010",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2020') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2020",
              statisticType: "sum"
            } 
          ];
           
          // query data for the pie chart
          const query = activeLayer.createQuery();
          query.geometry = view.extent;
          query.outStatistics = statDefinitions;
          return activeLayer.queryFeatures(query).then((result) => {
            const allStats = result.features[0].attributes;
            document.getElementById("countDiv").innerHTML = allStats.total;
          
            typeChart.options.title.text = "Housing Type"
            typeChart.update();

            updateChart(typeChart, [
              allStats.single_family,
              allStats.duplex,
              allStats.single_family_adu,
              allStats.condo,
              allStats.townhome,
              allStats.mobile_home_park,
              allStats.mixed_th_single_family,
              allStats.apartment
            ]);

          }, console.error);
        }

        // Updates the given chart with new data
        function updateChart(chart, dataValues) {
          chart.data.datasets[0].data = dataValues;
          chart.update();
        }

        // Updates the given chart with new data
        function updateStackedChart(chart, labels, dataValues) {
          chart.data.labels = labels;
          chart.data.datasets = dataValues;
          chart.update();
        }

        // instantiate the year stacked chart
        function createYearChart() {
          // const yearCanvas = document.getElementById("year-chart");
          yearChart = new Chart(yearCanvas.getContext("2d"), {
            type: "bar",
            data: {
              labels: [],
              datasets: [
                {
                  label: null,
                  backgroundColor: "#149dcf",
                  data: []
                }
              ]
            },
            options: {
              // responsive: false,
              legend: {
                display: false
              },
              title: {
                display: true,
                text: "Built Decade",
                fontColor:"#FFFFFF",
                fontSize:13
              },
              scales: {
                xAxes: [
                  {
                    stacked: true,
                    ticks: {
                      beginAtZero: true,
                      precision: 0,
                      fontColor: '#FFFFFF'
                    },
                    gridLines:{color: '#ccc'}
                  }
                ],
                yAxes: [
                  {
                    stacked: true,
                    ticks:{
                      fontColor: '#FFFFFF'
                    },
                    gridLines:{color: '#ccc'}
                  }
                ]
              }
            }
          });
          yearCanvas.style.backgroundColor = 'rgba(75,75,75,1)';
          yearCanvas.style.border = '1px solid #ccc';
        }

        // instantiate the type pie chart
        function createTypeChart() {
          // const typeCanvas = document.getElementById("type-chart");
          typeChart = new Chart(typeCanvas.getContext("2d"), {
            type: "doughnut",
            data: {
              labels: ["single_family", "duplex", "single_family_adu", "condo", 
                       "townhome", "mobile_home_park", "mixed th/single_family", "apartment"],
              datasets: [
                {
                  backgroundColor: ["#FAECA7", "#FC921F", "#E60049", "#BD7EBE", 
                                    "#28C830", "#9E559C", '#1E8553', '#149ECE'],
                  borderWidth: 0,
                  data: [0, 0, 0, 0, 0, 0, 0, 0]
                }
              ]
            },
            options: {
              responsive: true,
              cutoutPercentage: 25,
              legend: {
                display:false,
                position: "top",
              },
              layout: {
                padding:{bottom: 15}
               },
              title: {
                display: true,
                text: "Housing Type",
                fontColor:"#FFFFFF",
                fontSize:13
              }
            }
          });
          typeCanvas.style.backgroundColor = 'rgba(75,75,75,1)';
          typeCanvas.style.border = '1px solid #ccc';
        }

        // create the charts
        createYearChart();
        createTypeChart();

        // when the extent is changed update the charts
        reactiveUtils.when(() => view.stationary === true, () => {
          queryStatisticsForYearChart();
          queryStatisticsForTypeChart();
        });

        // create an expand object for the charts
        const resultDiv = document.getElementById("resultDiv");
        const chartExpand = new Expand({
          expandIcon: "graph-bar-side-by-side",
          expandTooltip: "Statistics",
          view: view,
          content: resultDiv,
          expanded: true,
          group: "top-right"
        });

        view.when(() => {
                // get the first layer in the collection of operational layers in the WebMap
                // when the resources in the MapView have loaded.
                const legend = new Legend({
                  view: view,
                  layerInfos: [
                    {
                      layer: PointsLayer,
                      title: ""
                    },
                    {
                      layer: ParcelsLayer,
                      title: ""
                    }
                  ]
                });

                const legendExpand = new Expand({
                expandIcon: "legend",
                expandTooltip: "Legend",
                view: view,
                content: legend,
                group: "top-right"
                });

                // Add widget to the bottom right corner of the view
                view.ui.add(legendExpand, "top-right");
              });
        
        view.ui.add(infoDivExpand, "top-right");
        view.ui.add(chartExpand, { position: "top-right"});
        view.ui.add(bgExpand, "top-right");


        //===============================
        // urlParams Functionality
        //===============================
        view.when(() => {
          // if provide URL has searchParams update the map
          if (urlParamsToggle === true){
            if (providedURL.href.includes('?') === true) {
              var newURL = new URL(providedURL)
              var searchParams = newURL.searchParams;
              var geomParam = searchParams.get("geom");

              var countyParam = searchParams.get("cny");
              var cityParam = searchParams.get("cty");
              var centerParam = searchParams.get("ctr");
              var subtypeParam = searchParams.get("type");
              console.log(subtypeParam)

              var lrParam = searchParams.get("lr");
              var frParam = searchParams.get("fr");
              var brtParam = searchParams.get("brt");
              var fwyeParam = searchParams.get("fwye");
              var logOpParam = searchParams.get("op");

              var xParam = parseInt(searchParams.get("x"));
              var yParam = parseInt(searchParams.get("y"));
              var zoomParam = parseInt(searchParams.get("zoom"));
   
              if ((countyParam != 'None') && countyParam){
                countySelect.value = countyParam;
                countyQuery = `COUNTY = '${countyParam}'`
                // console.log(countyParam);
              };

              if ((cityParam != 'None') && cityParam){
                citySelect.value = cityParam;
                cityQuery = `CITY = '${cityParam}'`
              };

              // center url params
              if ((centerParam != 'None') && centerParam){
                centerSelect.value = centerParam;
                centerQuery = `CENTER = '${centerParam}'`
              };
              
              // subtype url params
              if ((subtypeParam != 'None') && subtypeParam){
                if (subtypeParam.includes(',')) {
                  subtypeParam = subtypeParam.split(',');
                  subtypeSelect.value = subtypeParam;
                subtypeQuery = `SUBTYPE IN (${subtypeParam})`
                } else{
                  subtypeSelect.value = subtypeParam;
                  subtypeQuery = `SUBTYPE IN ('${subtypeParam}')`
                }
              };

              // light rail url params
              if ((lrParam != 'None') && lrParam){
                inputLR.value = lrParam;
                LRquery = `DIST_LR <= '${lrParam}'`
              };

              if ((frParam != 'None') && frParam){
                inputFR.value = frParam;
                FRquery = `DIST_FR <= '${frParam}'`
              };

              if ((brtParam != 'None') && brtParam){
                inputBRT.value = brtParam;
                BRTquery = `DIST_BRT <= '${brtParam}'`
              };

              if ((fwyeParam != 'None') && fwyeParam){
                inputFWYE.value = fwyeParam;
                FWYEquery = `DIST_FWYE <= '${fwyeParam}'`
              };

              if ((logOpParam != 'None') && logOpParam){
                if (logOpParam === "And"){
                  andButton.click()
                }
                if (logOpParam === "Or"){
                  orButton.click()
                }
                logicOperator = logOpParam;
              };

              generateFullQuery();
              [PointsLayer, ParcelsLayer].forEach((layer) => { 
                layer.definitionExpression = fullQuery;
              });
              

              let pt = new Point({
                x: xParam,
                y: yParam,
                spatialReference: {
                  wkid: 3857
                }
              });

              // override center and zoom
              view.center = pt;
              view.zoom = zoomParam;

              if (geomParam === 'pcl'){
                ParcelsLayer.visible = true;
                PointsLayer.visible = false;
                activeLayer = ParcelsLayer;
              } if (geomParam === 'pt'){
                ParcelsLayer.visible = false;
                PointsLayer.visible = true;
                activeLayer = PointsLayer;
              }
            }
          } 
        });
        
        // Create URL params by watching when the extent is changed
        reactiveUtils.when(() => view.stationary === true, () => {
          // Get the new center of the view only when view is stationary.
          if (view.center) {
            // lat = view.center.latitude.toFixed(3)
            // lon = view.center.longitude.toFixed(3)
            x = view.center.x.toFixed(0)
            y = view.center.y.toFixed(0)
            zoom = view.zoom
            scale = view.scale
           
            // newURL = new URL(providedURL);
            
            if (ParcelsLayer.visible === true){newURL.searchParams.set("geom", 'pcl');};
            if (PointsLayer.visible === true){newURL.searchParams.set("geom", 'pt');};
            newURL.searchParams.set("x", x);
            newURL.searchParams.set("y", y);
            newURL.searchParams.set("zoom", zoom);
       
            var searchParams = newURL.searchParams;
            if (searchParams && searchParams.keys().next().done === false) {
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            // console.log(newURL.href)
            }
          }
        });

        

      });

    </script>
  </head>

  <body>
    <div id="info" >
      <div id="title" style="flex:1.4;" >Housing Inventory Explorer (Jan 2022)</div>
      
      <div id="title" style="flex:1;">
        <a href="https://wfrc.org/">
          <img src="images/logo.png"  height="45px" width="auto">
        </a>
      </div>
    </div>
    <div id="viewDiv"></div>
    <div id="timeSlider"></div>

    <div id="sidebarDiv" class="grid-container">
      <div class="grid-item">
        <div class="child1">
          <b>County</b>
        </div>
        <div class="child2">
          <calcite-select id="countySelect"></calcite-select>
        </div>
      </div>
    
      <div class="grid-item">
        <div class="child1">
          <b>From TRAX (mi)</b>
        </div>
        <div class="child2">
          <calcite-input id="inputLR" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
        </div>
      </div>
    
      <div class="grid-item">
        <div class="child1">
          <b>City</b>
        </div>
        <div class="child2">
          <calcite-select id="citySelect"></calcite-select>
        </div>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>From FrontRunner (mi)</b>
          </div>
          <div class="child2">
            <calcite-input id="inputFR" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
          </div>
        </label>
      </div>
    
      <div class="grid-item">
        <div class="child1">
          <b>Center</b>
        </div>
        <div class="child2">
          <calcite-select id="centerSelect"></calcite-select>
        </div>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>From BRT (mi)</b>
          </div>
          <div class="child2">
            <calcite-input id="inputBRT" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
          </div>
        </label>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>Housing Type</b>
          </div>
          <div class="child2">
            <calcite-combobox id="subtypeSelect" placeholder="select housing types" selection-display="single" selection-mode="multiple"></calcite-combobox>
          </div>
        </label>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>From FWY Exit (mi)</b>
          </div>
          <div class="child2">
            <calcite-input id="inputFWYE" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
          </div>
        </label>
      </div>

      <div class="grid-item2">
          <div class="child3">
            <input id="resetButton" type="button" value="Clear Filters" class="esri-button" style="background-color: #00619B;"/>
          </div>
      </div>

      <div class="grid-item2">
        <div  class="grid-container2">
          <div class="child4">
            <input id="andButton" type="button" value="And" class="esri-button" style="background-color: #00619B;"/>
          </div>

          <div class="child4">
            <input id="orButton" type="button" value="Or" class="esri-button" style="background-color: #797979;"/>
          </div>
        </div>
      </div>
    </div>

    <div id="infoDiv" class="esri-widget" >
      <h4 class="esri-widget__heading esri-editor__title" style="text-align:center">About this Application:</h4>
      <div class="esri-widget">
        <p>This map highlights the basic types and quantities of existing housing in Davis, Salt Lake and Weber counties.</p>
        <p> WFRC uses the County Assessor <a href="https://gis.utah.gov/data/cadastre/parcels/"> tax parcel GIS data</a> gathered annually by UGRC as a key input to its land use models and forecasts.</p>
        <p>The Housing Unit Inventory shown in this webmap is derived from January 1, 2022 residential data from the Assessors tax parcels, adding in unit count estimates for rental properties and grouping housing units together that share adjoining common areas (e.g. condos and HOAs).</p>
        <p>For more information about this dataset, consult our <a href="https://docs.google.com/document/d/1W-ZdTamoB-rMPg91OTFyEO3OlI5LE0Vq7meF3oKFgVM/edit">metadata</a> or contact <a href="mailto:analytics@wfrc.org"> analytics@wfrc.org</a>.</p>
        <br>
        <h4 class="esri-widget__heading esri-editor__title" style="text-align:center">How to use:</h4>
        <p>Each panel can be toggled on or off. The Chart panel updates on the fly using whatever data is visible on the map. The Basemap can be switched to a variety of options and a legend can also be toggled. When zoomed in close enough, you can click a feature on the map to show its attributes. </p>
        <p>The Filters panel (top-left) allows you filter the data by geographic extent (Counties, Cities, or Wasatch Choice Centers). It also allows you to filter the units by their proximity to transit stations and/or freeway exits. You can use the And/Or button to change the query logic for these categories. Finally, you can filter the data by year, using the hidden time slider in the bottom-left. </p>
        
      </div>
    </div>

    <div id="resultDiv" class="esri-widget">
      
      <div>
        Total Units in View:
        <div class="count" id="countDiv">0</div>
      </div>

      <br>

      <div class="section">
        <canvas id="year-chart" height="250" width="300"></canvas>
      </div>

      <br>
      <div class="section">
        <canvas id="type-chart" height="250" ></canvas>
      </div>
      
      <div class="section" >
        <p>These charts dynamically update according to the <b>visible</b> features in the map. Hover over an element in the chart to view its description.</p>
        

      </div>
    </div>


  </body>